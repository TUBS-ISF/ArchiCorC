/*
 * generated by Xtext 2.15.0
 */
package tu_bs.cs.isf.mapping.validation

import de.tu_bs.ccc.contracting.Verification.Module
import de.tu_bs.ccc.contracting.Verification.Ports
import de.tu_bs.ccc.contracting.core.localization.StringTable
import de.tu_bs.ccc.contracting.core.util.CoreUtil
import de.tu_bs.ccc.contracting.idl.cidl.Interface
import de.tu_bs.ccc.contracting.idl.cidl.Method
import de.tu_bs.cs.isf.cbc.cbcmodel.AbstractStatement
import de.tu_bs.cs.isf.cbc.cbcmodel.Condition
import de.tu_bs.cs.isf.cbc.cbcmodel.JavaVariables
import java.io.File
import java.util.Collection
import java.util.List
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IWorkspace
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.graphiti.mm.pictograms.Diagram
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import tu_bs.cs.isf.mapping.mapping.CbcDiagram
import tu_bs.cs.isf.mapping.mapping.Component
import tu_bs.cs.isf.mapping.mapping.Mapping
import tu_bs.cs.isf.mapping.mapping.MappingModel
import tu_bs.cs.isf.mapping.mapping.MappingPackage
import tu_bs.cs.isf.mapping.mapping.MappingPair
import tu_bs.cs.isf.mapping.mapping.ServiceMethod
import tu_bs.cs.isf.mapping.mapping.impl.ComponentImpl
import tu_bs.cs.isf.mapping.mapping.impl.MappingImpl
import tu_bs.cs.isf.mapping.mapping.impl.MappingModelImpl
import tu_bs.cs.isf.mapping.solver.KeyProve
import de.tu_bs.ccc.contracting.idl.cidl.ContractPair
import tu_bs.cs.isf.mapping.solver.Encoding
import de.tu_bs.cs.isf.cbc.cbcmodel.CbcmodelFactory
import de.tu_bs.cs.isf.cbc.cbcmodel.GlobalConditions
import org.eclipse.graphiti.mm.pictograms.Shape
import de.tu_bs.cs.isf.cbc.cbcmodel.Renaming
import tu_bs.cs.isf.mapping.solver.CreateStubsForService
import tu_bs.cs.isf.mapping.solver.Prover
import org.eclipse.emf.common.util.URI

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MappingValidator extends AbstractMappingValidator {
	public static val INVALID_NAME = 'invalidName'
	public static val String root = ResourcesPlugin.workspace.root.location.toOSString
	public val IWorkspace workspace = ResourcesPlugin.workspace
	
	@Check
	def checkMappingIsCorrect (Mapping m) {
		val EStructuralFeature sf = MappingPackage.Literals.MAPPING__NAME
		val EObject modelOfMapping = m.eContainer
		//val MappingModel model = MappingModelImpl.cast(modelOfMapping)
		val MappingModel model = modelOfMapping as MappingModel
		val EList<Mapping> maps = model.getMappings
		var int counter = 0
		
		if (!Character.isUpperCase(m.name.charAt(0))) {
			warning('Name should start with a capital', sf, INVALID_NAME)
		}
		for (i : 0 ..< maps.size){
			val Mapping mapping = MappingImpl.cast(maps.get(i))
			
			if (mapping.name.equals(m.name)){
				counter=counter+1
			}
		}
		if (counter > 1){
			error('MappingName already exists', sf, INVALID_NAME)
		}
	}
	
	@Check
	def checkComponentIsCorrect(Component c){
		val String filePath = FileFinder.path(c, c.name, root)
		val File f = new File(filePath)
		val EStructuralFeature sf = MappingPackage.Literals.COMPONENT__NAME		
		
		if (!f.exists){
	    	error('File does not exist in folder src', sf, INVALID_NAME)
		} else if (!c.name.endsWith(StringTable.DIAGRAM_FILE_EXTENSION)) {
			error('File must be of type cide: *.cide', sf, INVALID_NAME)
		} else if (!c.name.startsWith("repository/")) {
			warning('File should be in folder repository', sf, INVALID_NAME)
		}
		
	}
	
@Check
def checkServiceMethodIsCorrect(ServiceMethod sm){
	val EStructuralFeature sf = MappingPackage.Literals.SERVICE_METHOD__NAME
			
	if (!(sm.name.contains("."))){
    	error('Require "portName.methodName"', sf, INVALID_NAME)
		}else{
			val String[] smParts = sm.name.split("\\.")
			val String portName = smParts.get(0)
			val String methodName = smParts.get(1)
			val EObject smComponent = sm.eContainer.eContainer
			val Component c = ComponentImpl.cast(smComponent)
			val String componentPath = FileFinder.path(c, c.name, root)
			val IFile f = FileFinder.file(componentPath, workspace)
			
			if (f.exists){
				val IProject p = f.project
				val Collection<Module> cm = CoreUtil.getRootModules(p)
				
			
				for	(i : 0 ..< cm.size){
					if (c.name.endsWith(StringTable.DIAGRAM_FILE_EXTENSION)){
						val String[] parts = c.name.split("\\.")
						//componentName without ".cide"
						var String name = parts.get(parts.size-2)
					
						if (name.contains("/")){
							val String[] parts2= name.split("/")
							name = parts2.get(parts2.size-1)
						}
					
						//current Module
						if(name.equals(cm.get(i).name)){
							val EList<Ports> ports = cm.get(i).ports
							var boolean existingPort = false
							var boolean typeNotSERVICE = false
							var boolean existingMethod = false
						
							for (j : 0 ..< ports.size){
								if (portName.equals(ports.get(j).name)){
									existingPort = true
									if (ports.get(j).type.getName.equals("SERVICE")){
										val List<Interface> interfaces = CideMethods.getInterfaces(p)
									
										for	(k : 0 ..< interfaces.size){
											if (interfaces.get(k).name.equals(ports.get(j).service)){
												val EList<Method> methods = interfaces.get(k).methods
											
												for (l : 0 ..< methods.size){
													if (methods.get(l).name.equals(methodName)){
														existingMethod = true
													}
												}
											}
										}	
									} else {
										typeNotSERVICE = true
									}
								} 
							}
							if (!existingPort) {
								error('portName does not exist', sf, INVALID_NAME)
							} else if (typeNotSERVICE) {
								warning('portType is not SERVICE', sf, INVALID_NAME)
							} else if (!existingMethod){
								error('Method does not exist', sf, INVALID_NAME)
							}
						}
					}
				}
			}
		}
	}
	
	@Check (CheckType.FAST)
	def checkCbcDiagramIsCorrect(CbcDiagram d){
		val String filePath = FileFinder.path(d, d.name, root)
		val File f = new File(filePath)
		val EStructuralFeature sf = MappingPackage.Literals.CBC_DIAGRAM__NAME
		
		if (!f.exists){
	    	error('File does not exist in folder src', sf, INVALID_NAME)
	    } else if (!d.name.endsWith(".diagram")) {
			error('File must be of type diagram: *.diagram', sf, INVALID_NAME)
		} else if (!d.name.startsWith("CorC/")) {
			warning('File should be in folder CorC', sf, INVALID_NAME)
		}
		
	}
	
	@Check (CheckType.EXPENSIVE)
	def checkMappingPairIsCorrect(MappingPair mp){
		val ServiceMethod sm = mp.getPort
		val CbcDiagram cbc = mp.diagram
		
		val EStructuralFeature sf = MappingPackage.Literals.MAPPING_PAIR__DIAGRAM
		val EStructuralFeature sf2 = MappingPackage.Literals.MAPPING_PAIR__PORT
				
		if (CorrectMappingPair.correctMappingPair(cbc, sm, root, workspace)){
			
			val String cbcPath = FileFinder.path(cbc, cbc.name, root)
			val IFile f = FileFinder.file(cbcPath, workspace)
			
			val IProject p = f.project
			val List<Interface> interfaces = CideMethods.getInterfaces(p)
			CreateStubsForService.create(sm, interfaces, root)
			
			
			
			val Diagram d = CorcMethods.getShapes(cbc, root, workspace).get(0).container as Diagram
			
			val String method = sm.name
			val List<ContractPair> cideContractPairs = CideMethods.getContractPair(sm, root, workspace)
			val List<Condition> conditions = Encoding.getCondition(cideContractPairs)
			val Condition cidePre = conditions.get(0)
			val Condition cidePost = conditions.get(1)			
			val List<Shape> shapes = CorcMethods.getShapes(cbc, root, workspace)
			val AbstractStatement corcStatement = CorcMethods.getContractPair(shapes)
			val Condition corcPre = corcStatement.preCondition
			val Condition corcPost = corcStatement.postCondition
			val JavaVariables corcVars = CorcMethods.getJavaVariables(shapes)
			val GlobalConditions corcConds = CorcMethods.getGlobalConditions(shapes)
			val Renaming corcRenaming = CorcMethods.getRenaming(shapes)
			Console.println(sm.name+" -> "+cbc.name)
			//Console.println("cide pre: "+cidePre.name+" post: "+cidePost.name)
			//Console.println("corc pre: "+corcPre.name+" post: "+corcPost.name)
			
			val Prover prover = new KeyProve(method, cidePre, cidePost, corcPre, corcPost, corcVars, corcConds, corcRenaming, d.eResource.URI);
        	val int[] provePreCideCorc = prover.provePreCideCorc
        	val int[] provePostCorcCide = prover.provePostCorcCide
        	
        	//status: 0 - proven, 1 - interactively proven, 2 - Timeout, 3 - OpenGoals, 4 - not proven, 5 - unknown
        	switch(provePreCideCorc.get(0)){
        		case 0: 
        			Console.println("Verify CidePre -> CorcPre: proven, steps: "+provePreCideCorc.get(1).toString+", time in ms: "+provePreCideCorc.get(2).toString)        			
        		case 1: 
        			Console.println("Verify CidePre -> CorcPre: interactively proven, steps: "+provePreCideCorc.get(1).toString+", time in ms: "+provePreCideCorc.get(2).toString)
        		case 2:
        			Console.println("Verify CidePre -> CorcPre: Timeout, steps: "+provePreCideCorc.get(1).toString+", time in ms: "+provePreCideCorc.get(2).toString)
        		case 3:
        			Console.println("Verify CidePre -> CorcPre: OpenGoals, steps: "+provePreCideCorc.get(1).toString+", time in ms: "+provePreCideCorc.get(2).toString)
        		case 4:
        			Console.println("Verify CidePre -> CorcPre: not proven, steps: "+provePreCideCorc.get(1).toString+", time in ms: "+provePreCideCorc.get(2).toString)
        		case 5:
        			Console.println("Verify CidePre -> CorcPre: unknown, steps: "+provePreCideCorc.get(1).toString+", time in ms: "+provePreCideCorc.get(2).toString)
        	}
        	
        	switch(provePostCorcCide.get(0)){
        		case 0: 
        			Console.println("Verify CorcPost -> CidePost: proven, steps: "+provePostCorcCide.get(1).toString+", time in ms: "+provePostCorcCide.get(2).toString)
        		case 1: 
        			Console.println("Verify CorcPost -> CidePost: interactively proven, steps: "+provePostCorcCide.get(1).toString+", time in ms: "+provePostCorcCide.get(2).toString)
        		case 2:
        			Console.println("Verify CorcPost -> CidePost: Timeout, steps: "+provePostCorcCide.get(1).toString+", time in ms: "+provePostCorcCide.get(2).toString)
        		case 3:
        			Console.println("Verify CorcPost -> CidePost: OpenGoals, steps: "+provePostCorcCide.get(1).toString+", time in ms: "+provePostCorcCide.get(2).toString)
        		case 4:
        			Console.println("Verify CorcPost -> CidePost: not proven, steps: "+provePostCorcCide.get(1).toString+", time in ms: "+provePostCorcCide.get(2).toString)
        		case 5:
        			Console.println("Verify CorcPost -> CidePost: unknown, steps: "+provePostCorcCide.get(1).toString+", time in ms: "+provePostCorcCide.get(2).toString)
        	}
        	
        	if((provePreCideCorc.get(0) == 0 || provePreCideCorc.get(0) == 1) && (provePostCorcCide.get(0) == 0 || provePostCorcCide.get(0) == 1)){
        		Console.println("Mapping is correct")
        		info('proven', sf, INVALID_NAME)
        		info('proven', sf2, INVALID_NAME)
        		
        	} else {
        		Console.println("Mapping is not correct")
        	}
        	
			Console.println(" ")
		}
	}
}