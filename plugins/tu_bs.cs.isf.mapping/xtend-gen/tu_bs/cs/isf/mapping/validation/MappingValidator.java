/**
 * generated by Xtext 2.15.0
 */
package tu_bs.cs.isf.mapping.validation;

import de.tu_bs.ccc.contracting.Verification.Ports;
import de.tu_bs.ccc.contracting.core.localization.StringTable;
import de.tu_bs.ccc.contracting.core.util.CoreUtil;
import de.tu_bs.ccc.contracting.idl.cidl.ContractPair;
import de.tu_bs.ccc.contracting.idl.cidl.Interface;
import de.tu_bs.ccc.contracting.idl.cidl.Method;
import de.tu_bs.cs.isf.cbc.cbcmodel.AbstractStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.Condition;
import de.tu_bs.cs.isf.cbc.cbcmodel.GlobalConditions;
import de.tu_bs.cs.isf.cbc.cbcmodel.JavaVariables;
import de.tu_bs.cs.isf.cbc.cbcmodel.Renaming;
import java.io.File;
import java.util.Collection;
import java.util.List;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.graphiti.mm.pictograms.ContainerShape;
import org.eclipse.graphiti.mm.pictograms.Diagram;
import org.eclipse.graphiti.mm.pictograms.Shape;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import tu_bs.cs.isf.mapping.mapping.CbcDiagram;
import tu_bs.cs.isf.mapping.mapping.Component;
import tu_bs.cs.isf.mapping.mapping.Mapping;
import tu_bs.cs.isf.mapping.mapping.MappingModel;
import tu_bs.cs.isf.mapping.mapping.MappingPackage;
import tu_bs.cs.isf.mapping.mapping.MappingPair;
import tu_bs.cs.isf.mapping.mapping.ServiceMethod;
import tu_bs.cs.isf.mapping.mapping.impl.ComponentImpl;
import tu_bs.cs.isf.mapping.mapping.impl.MappingImpl;
import tu_bs.cs.isf.mapping.mapping.impl.MappingModelImpl;
import tu_bs.cs.isf.mapping.solver.Console;
import tu_bs.cs.isf.mapping.solver.CreateStubsForService;
import tu_bs.cs.isf.mapping.solver.Encoding;
import tu_bs.cs.isf.mapping.solver.KeyProve;
import tu_bs.cs.isf.mapping.solver.Prover;
import tu_bs.cs.isf.mapping.validation.AbstractMappingValidator;
import tu_bs.cs.isf.mapping.validation.CideMethods;
import tu_bs.cs.isf.mapping.validation.CorcMethods;
import tu_bs.cs.isf.mapping.validation.CorrectMappingPair;
import tu_bs.cs.isf.mapping.validation.FileFinder;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MappingValidator extends AbstractMappingValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String root = ResourcesPlugin.getWorkspace().getRoot().getLocation().toOSString();
  
  public final IWorkspace workspace = ResourcesPlugin.getWorkspace();
  
  @Check
  public void checkMappingIsCorrect(final Mapping m) {
    final EStructuralFeature sf = MappingPackage.Literals.MAPPING__NAME;
    final EObject modelOfMapping = m.eContainer();
    final MappingModel model = MappingModelImpl.class.cast(modelOfMapping);
    final EList<Mapping> maps = model.getMappings();
    int counter = 0;
    boolean _isUpperCase = Character.isUpperCase(m.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Name should start with a capital", sf, MappingValidator.INVALID_NAME);
    }
    int _size = maps.size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Mapping mapping = MappingImpl.class.cast(maps.get((i).intValue()));
        boolean _equals = mapping.getName().equals(m.getName());
        if (_equals) {
          counter = (counter + 1);
        }
      }
    }
    if ((counter > 1)) {
      this.error("MappingName already exists", sf, MappingValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkComponentIsCorrect(final Component c) {
    final String filePath = FileFinder.path(c, c.getName(), MappingValidator.root);
    final File f = new File(filePath);
    final EStructuralFeature sf = MappingPackage.Literals.COMPONENT__NAME;
    boolean _exists = f.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.error("File does not exist in folder src", sf, MappingValidator.INVALID_NAME);
    }
    boolean _startsWith = c.getName().startsWith("repository/");
    boolean _not_1 = (!_startsWith);
    if (_not_1) {
      this.warning("File should be in folder repository", sf, MappingValidator.INVALID_NAME);
    }
    boolean _endsWith = c.getName().endsWith(StringTable.DIAGRAM_FILE_EXTENSION);
    boolean _not_2 = (!_endsWith);
    if (_not_2) {
      this.error("File must be of type cide: *.cide", sf, MappingValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkServiceMethodIsCorrect(final ServiceMethod sm) {
    final EStructuralFeature sf = MappingPackage.Literals.SERVICE_METHOD__NAME;
    boolean _contains = sm.getName().contains(".");
    boolean _not = (!_contains);
    if (_not) {
      this.error("Require \"portName.methodName\"", sf, MappingValidator.INVALID_NAME);
    } else {
      final String[] smParts = sm.getName().split("\\.");
      final String portName = smParts[0];
      final String methodName = smParts[1];
      final EObject smComponent = sm.eContainer().eContainer();
      final Component c = ComponentImpl.class.cast(smComponent);
      final String componentPath = FileFinder.path(c, c.getName(), MappingValidator.root);
      final IFile f = FileFinder.file(componentPath, this.workspace);
      boolean _exists = f.exists();
      if (_exists) {
        final IProject p = f.getProject();
        final Collection<de.tu_bs.ccc.contracting.Verification.Module> cm = CoreUtil.getRootModules(p);
        int _size = cm.size();
        ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
        for (final Integer i : _doubleDotLessThan) {
          boolean _endsWith = c.getName().endsWith(StringTable.DIAGRAM_FILE_EXTENSION);
          if (_endsWith) {
            final String[] parts = c.getName().split("\\.");
            int _size_1 = ((List<String>)Conversions.doWrapArray(parts)).size();
            int _minus = (_size_1 - 2);
            String name = parts[_minus];
            boolean _contains_1 = name.contains("/");
            if (_contains_1) {
              final String[] parts2 = name.split("/");
              int _size_2 = ((List<String>)Conversions.doWrapArray(parts2)).size();
              int _minus_1 = (_size_2 - 1);
              name = parts2[_minus_1];
            }
            boolean _equals = name.equals(((de.tu_bs.ccc.contracting.Verification.Module[])Conversions.unwrapArray(cm, de.tu_bs.ccc.contracting.Verification.Module.class))[(i).intValue()].getName());
            if (_equals) {
              final EList<Ports> ports = ((de.tu_bs.ccc.contracting.Verification.Module[])Conversions.unwrapArray(cm, de.tu_bs.ccc.contracting.Verification.Module.class))[(i).intValue()].getPorts();
              boolean existingPort = false;
              boolean typeNotSERVICE = false;
              boolean existingMethod = false;
              int _size_3 = ports.size();
              ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, _size_3, true);
              for (final Integer j : _doubleDotLessThan_1) {
                boolean _equals_1 = portName.equals(ports.get((j).intValue()).getName());
                if (_equals_1) {
                  existingPort = true;
                  boolean _equals_2 = ports.get((j).intValue()).getType().getName().equals("SERVICE");
                  if (_equals_2) {
                    final List<Interface> interfaces = CideMethods.interfaces(p);
                    int _size_4 = interfaces.size();
                    ExclusiveRange _doubleDotLessThan_2 = new ExclusiveRange(0, _size_4, true);
                    for (final Integer k : _doubleDotLessThan_2) {
                      boolean _equals_3 = interfaces.get((k).intValue()).getName().equals(ports.get((j).intValue()).getService());
                      if (_equals_3) {
                        final EList<Method> methods = interfaces.get((k).intValue()).getMethods();
                        int _size_5 = methods.size();
                        ExclusiveRange _doubleDotLessThan_3 = new ExclusiveRange(0, _size_5, true);
                        for (final Integer l : _doubleDotLessThan_3) {
                          boolean _equals_4 = methods.get((l).intValue()).getName().equals(methodName);
                          if (_equals_4) {
                            existingMethod = true;
                          }
                        }
                      }
                    }
                  } else {
                    typeNotSERVICE = true;
                  }
                }
              }
              if ((!existingPort)) {
                this.error("portName does not exist", sf, MappingValidator.INVALID_NAME);
              } else {
                if (typeNotSERVICE) {
                  this.warning("portType is not SERVICE", sf, MappingValidator.INVALID_NAME);
                } else {
                  if ((!existingMethod)) {
                    this.error("Method does not exist", sf, MappingValidator.INVALID_NAME);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkCbcDiagramIsCorrect(final CbcDiagram d) {
    final String filePath = FileFinder.path(d, d.getName(), MappingValidator.root);
    final File f = new File(filePath);
    final EStructuralFeature sf = MappingPackage.Literals.CBC_DIAGRAM__NAME;
    boolean _exists = f.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.error("File does not exist", sf, MappingValidator.INVALID_NAME);
    } else {
      boolean _endsWith = d.getName().endsWith(".diagram");
      boolean _not_1 = (!_endsWith);
      if (_not_1) {
        this.error("File must be of type diagram: *.diagram", sf, MappingValidator.INVALID_NAME);
      } else {
        boolean _startsWith = d.getName().startsWith("CorC/");
        boolean _not_2 = (!_startsWith);
        if (_not_2) {
          this.warning("File should be in folder CorC", sf, MappingValidator.INVALID_NAME);
        }
      }
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void port(final MappingPair mp) {
    final ServiceMethod sm = mp.getPort();
    final CbcDiagram cbc = mp.getDiagram();
    boolean _correctMappingPair = CorrectMappingPair.correctMappingPair(cbc, sm, MappingValidator.root, this.workspace);
    if (_correctMappingPair) {
      final String cbcPath = FileFinder.path(cbc, cbc.getName(), MappingValidator.root);
      final IFile f = FileFinder.file(cbcPath, this.workspace);
      final IProject p = f.getProject();
      final List<Interface> interfaces = CideMethods.interfaces(p);
      CreateStubsForService.create(sm, interfaces, MappingValidator.root);
      ContainerShape _container = CorcMethods.getShapes(cbc, MappingValidator.root, this.workspace).get(0).getContainer();
      final Diagram d = ((Diagram) _container);
      final List<ContractPair> cideContractPairs = CideMethods.getContractPair(sm, MappingValidator.root, this.workspace);
      final List<Condition> conditions = Encoding.getCondition(cideContractPairs);
      final Condition cidePre = conditions.get(0);
      final Condition cidePost = conditions.get(1);
      final List<Shape> shapes = CorcMethods.getShapes(cbc, MappingValidator.root, this.workspace);
      final AbstractStatement corcStatement = CorcMethods.getContractPair(shapes);
      final Condition corcPre = corcStatement.getPreCondition();
      final Condition corcPost = corcStatement.getPostCondition();
      final JavaVariables corcVars = CorcMethods.getJavaVariables(shapes);
      final GlobalConditions corcConds = CorcMethods.getGlobalConditions(shapes);
      final Renaming corcRenaming = CorcMethods.getRenaming(shapes);
      String _name = sm.getName();
      String _plus = (_name + " -> ");
      String _name_1 = cbc.getName();
      String _plus_1 = (_plus + _name_1);
      Console.println(_plus_1);
      URI _uRI = d.eResource().getURI();
      final Prover prover = new KeyProve(cidePre, cidePost, corcPre, corcPost, corcVars, corcConds, corcRenaming, _uRI);
      final int provePreCideCorc = prover.provePreCideCorc();
      final int provePostCorcCide = prover.provePostCorcCide();
      switch (provePreCideCorc) {
        case 0:
          Console.println("Verify CidePre -> CorcPre: proven");
          break;
        case 1:
          Console.println("Verify CidePre -> CorcPre: interactively proven");
          break;
        case 2:
          Console.println("Verify CidePre -> CorcPre: TimeOut");
          break;
        case 3:
          Console.println("Verify CidePre -> CorcPre: OpenGoals");
          break;
        case 4:
          Console.println("Verify CidePre -> CorcPre: not proven");
          break;
        case 5:
          Console.println("Verify CidePre -> CorcPre: unknown");
          break;
      }
      switch (provePostCorcCide) {
        case 0:
          Console.println("Verify CorcPost -> CidePost: proven");
          break;
        case 1:
          Console.println("Verify CorcPost -> CidePost: interactively proven");
          break;
        case 2:
          Console.println("Verify CorcPost -> CidePost: TimeOut");
          break;
        case 3:
          Console.println("Verify CorcPost -> CidePost: OpenGoals");
          break;
        case 4:
          Console.println("Verify CorcPost -> CidePost: not proven");
          break;
        case 5:
          Console.println("Verify CorcPost -> CidePost: unknown");
          break;
      }
      if (((provePreCideCorc == 0) && (provePostCorcCide == 0))) {
        Console.println("Mapping is correct");
      } else {
        Console.println("Mapping is not correct");
      }
      Console.println(" ");
    }
  }
}
