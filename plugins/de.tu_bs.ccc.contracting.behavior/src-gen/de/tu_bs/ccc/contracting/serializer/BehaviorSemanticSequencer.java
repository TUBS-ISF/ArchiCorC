/*
 * generated by Xtext 2.20.0
 */
package de.tu_bs.ccc.contracting.serializer;

import com.google.inject.Inject;
import de.tu_bs.ccc.contracting.behavior.Annotation;
import de.tu_bs.ccc.contracting.behavior.AnnotationBlock;
import de.tu_bs.ccc.contracting.behavior.Behavior;
import de.tu_bs.ccc.contracting.behavior.BehaviorModel;
import de.tu_bs.ccc.contracting.behavior.BehaviorPackage;
import de.tu_bs.ccc.contracting.behavior.Broadcast;
import de.tu_bs.ccc.contracting.behavior.ContractPair;
import de.tu_bs.ccc.contracting.behavior.DetailCode;
import de.tu_bs.ccc.contracting.behavior.Ensures;
import de.tu_bs.ccc.contracting.behavior.Event;
import de.tu_bs.ccc.contracting.behavior.EventBinding;
import de.tu_bs.ccc.contracting.behavior.EventOnIf;
import de.tu_bs.ccc.contracting.behavior.EventTrigger;
import de.tu_bs.ccc.contracting.behavior.FArgument;
import de.tu_bs.ccc.contracting.behavior.FArrayType;
import de.tu_bs.ccc.contracting.behavior.FBinaryOperation;
import de.tu_bs.ccc.contracting.behavior.FBooleanConstant;
import de.tu_bs.ccc.contracting.behavior.FBracketInitializer;
import de.tu_bs.ccc.contracting.behavior.FCompoundInitializer;
import de.tu_bs.ccc.contracting.behavior.FConstantDef;
import de.tu_bs.ccc.contracting.behavior.FDeclaration;
import de.tu_bs.ccc.contracting.behavior.FDoubleConstant;
import de.tu_bs.ccc.contracting.behavior.FElementInitializer;
import de.tu_bs.ccc.contracting.behavior.FEventOnIf;
import de.tu_bs.ccc.contracting.behavior.FField;
import de.tu_bs.ccc.contracting.behavior.FFieldInitializer;
import de.tu_bs.ccc.contracting.behavior.FFloatConstant;
import de.tu_bs.ccc.contracting.behavior.FGuard;
import de.tu_bs.ccc.contracting.behavior.FIntegerConstant;
import de.tu_bs.ccc.contracting.behavior.FIntegerInterval;
import de.tu_bs.ccc.contracting.behavior.FMapType;
import de.tu_bs.ccc.contracting.behavior.FQualifiedElementRef;
import de.tu_bs.ccc.contracting.behavior.FState;
import de.tu_bs.ccc.contracting.behavior.FStateGraph;
import de.tu_bs.ccc.contracting.behavior.FStringConstant;
import de.tu_bs.ccc.contracting.behavior.FStructType;
import de.tu_bs.ccc.contracting.behavior.FTransition;
import de.tu_bs.ccc.contracting.behavior.FTrigger;
import de.tu_bs.ccc.contracting.behavior.FTypeDef;
import de.tu_bs.ccc.contracting.behavior.FTypeRef;
import de.tu_bs.ccc.contracting.behavior.FUnaryOperation;
import de.tu_bs.ccc.contracting.behavior.FUnionType;
import de.tu_bs.ccc.contracting.behavior.Import;
import de.tu_bs.ccc.contracting.behavior.MethodSignature;
import de.tu_bs.ccc.contracting.behavior.RefableType;
import de.tu_bs.ccc.contracting.behavior.Requires;
import de.tu_bs.ccc.contracting.behavior.Signal;
import de.tu_bs.ccc.contracting.behavior.SignalSignature;
import de.tu_bs.ccc.contracting.behavior.SpecificationBlock;
import de.tu_bs.ccc.contracting.behavior.StandardOperation;
import de.tu_bs.ccc.contracting.behavior.VarDecl;
import de.tu_bs.ccc.contracting.services.BehaviorGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BehaviorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BehaviorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BehaviorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BehaviorPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case BehaviorPackage.ANNOTATION_BLOCK:
				sequence_AnnotationBlock(context, (AnnotationBlock) semanticObject); 
				return; 
			case BehaviorPackage.BEHAVIOR:
				sequence_Behavior(context, (Behavior) semanticObject); 
				return; 
			case BehaviorPackage.BEHAVIOR_MODEL:
				sequence_BehaviorModel(context, (BehaviorModel) semanticObject); 
				return; 
			case BehaviorPackage.BROADCAST:
				sequence_Broadcast(context, (Broadcast) semanticObject); 
				return; 
			case BehaviorPackage.CONTRACT_PAIR:
				sequence_ContractPair(context, (ContractPair) semanticObject); 
				return; 
			case BehaviorPackage.DETAIL_CODE:
				sequence_DetailCode(context, (DetailCode) semanticObject); 
				return; 
			case BehaviorPackage.ENSURES:
				sequence_Ensures(context, (Ensures) semanticObject); 
				return; 
			case BehaviorPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case BehaviorPackage.EVENT_BINDING:
				sequence_EventBinding(context, (EventBinding) semanticObject); 
				return; 
			case BehaviorPackage.EVENT_ON_IF:
				sequence_EventOnIf(context, (EventOnIf) semanticObject); 
				return; 
			case BehaviorPackage.EVENT_TRIGGER:
				sequence_EventTrigger(context, (EventTrigger) semanticObject); 
				return; 
			case BehaviorPackage.FARGUMENT:
				sequence_FArgument(context, (FArgument) semanticObject); 
				return; 
			case BehaviorPackage.FARRAY_TYPE:
				sequence_FArrayType(context, (FArrayType) semanticObject); 
				return; 
			case BehaviorPackage.FBINARY_OPERATION:
				sequence_AdditiveExpression_EqualityExpression_LogicalAndExpression_LogicalOrExpression_MultiplicativeExpression_RelationalExpression(context, (FBinaryOperation) semanticObject); 
				return; 
			case BehaviorPackage.FBOOLEAN_CONSTANT:
				sequence_FBooleanConstant(context, (FBooleanConstant) semanticObject); 
				return; 
			case BehaviorPackage.FBRACKET_INITIALIZER:
				sequence_FBracketInitializer(context, (FBracketInitializer) semanticObject); 
				return; 
			case BehaviorPackage.FCOMPOUND_INITIALIZER:
				sequence_FCompoundInitializer(context, (FCompoundInitializer) semanticObject); 
				return; 
			case BehaviorPackage.FCONSTANT_DEF:
				sequence_FConstantDef(context, (FConstantDef) semanticObject); 
				return; 
			case BehaviorPackage.FDECLARATION:
				sequence_FDeclaration(context, (FDeclaration) semanticObject); 
				return; 
			case BehaviorPackage.FDOUBLE_CONSTANT:
				sequence_FDoubleConstant(context, (FDoubleConstant) semanticObject); 
				return; 
			case BehaviorPackage.FELEMENT_INITIALIZER:
				sequence_FElementInitializer(context, (FElementInitializer) semanticObject); 
				return; 
			case BehaviorPackage.FEVENT_ON_IF:
				sequence_FEventOnIf(context, (FEventOnIf) semanticObject); 
				return; 
			case BehaviorPackage.FFIELD:
				sequence_FField(context, (FField) semanticObject); 
				return; 
			case BehaviorPackage.FFIELD_INITIALIZER:
				sequence_FFieldInitializer(context, (FFieldInitializer) semanticObject); 
				return; 
			case BehaviorPackage.FFLOAT_CONSTANT:
				sequence_FFloatConstant(context, (FFloatConstant) semanticObject); 
				return; 
			case BehaviorPackage.FGUARD:
				sequence_FGuard(context, (FGuard) semanticObject); 
				return; 
			case BehaviorPackage.FINTEGER_CONSTANT:
				sequence_FIntegerConstant(context, (FIntegerConstant) semanticObject); 
				return; 
			case BehaviorPackage.FINTEGER_INTERVAL:
				sequence_FIntegerInterval(context, (FIntegerInterval) semanticObject); 
				return; 
			case BehaviorPackage.FMAP_TYPE:
				sequence_FMapType(context, (FMapType) semanticObject); 
				return; 
			case BehaviorPackage.FQUALIFIED_ELEMENT_REF:
				sequence_FQualifiedElementRef(context, (FQualifiedElementRef) semanticObject); 
				return; 
			case BehaviorPackage.FSTATE:
				sequence_FState(context, (FState) semanticObject); 
				return; 
			case BehaviorPackage.FSTATE_GRAPH:
				sequence_FStateGraph(context, (FStateGraph) semanticObject); 
				return; 
			case BehaviorPackage.FSTRING_CONSTANT:
				sequence_FStringConstant(context, (FStringConstant) semanticObject); 
				return; 
			case BehaviorPackage.FSTRUCT_TYPE:
				sequence_FStructType(context, (FStructType) semanticObject); 
				return; 
			case BehaviorPackage.FTRANSITION:
				sequence_FTransition(context, (FTransition) semanticObject); 
				return; 
			case BehaviorPackage.FTRIGGER:
				sequence_FTrigger(context, (FTrigger) semanticObject); 
				return; 
			case BehaviorPackage.FTYPE_DEF:
				sequence_FTypeDef(context, (FTypeDef) semanticObject); 
				return; 
			case BehaviorPackage.FTYPE_REF:
				sequence_FTypeRef(context, (FTypeRef) semanticObject); 
				return; 
			case BehaviorPackage.FUNARY_OPERATION:
				sequence_FUnaryOperation(context, (FUnaryOperation) semanticObject); 
				return; 
			case BehaviorPackage.FUNION_TYPE:
				sequence_FUnionType(context, (FUnionType) semanticObject); 
				return; 
			case BehaviorPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case BehaviorPackage.METHOD_SIGNATURE:
				sequence_MethodSignature(context, (MethodSignature) semanticObject); 
				return; 
			case BehaviorPackage.REFABLE_TYPE:
				sequence_RefableType(context, (RefableType) semanticObject); 
				return; 
			case BehaviorPackage.REQUIRES:
				sequence_Requires(context, (Requires) semanticObject); 
				return; 
			case BehaviorPackage.SIGNAL:
				sequence_Signal(context, (Signal) semanticObject); 
				return; 
			case BehaviorPackage.SIGNAL_SIGNATURE:
				sequence_SignalSignature(context, (SignalSignature) semanticObject); 
				return; 
			case BehaviorPackage.SPECIFICATION_BLOCK:
				sequence_SpecificationBlock(context, (SpecificationBlock) semanticObject); 
				return; 
			case BehaviorPackage.STANDARD_OPERATION:
				sequence_StandardOperation(context, (StandardOperation) semanticObject); 
				return; 
			case BehaviorPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FBinaryOperation
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FBinaryOperation
	 *     LogicalAndExpression returns FBinaryOperation
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FBinaryOperation
	 *     EqualityExpression returns FBinaryOperation
	 *     EqualityExpression.FBinaryOperation_1_0 returns FBinaryOperation
	 *     RelationalExpression returns FBinaryOperation
	 *     RelationalExpression.FBinaryOperation_1_0 returns FBinaryOperation
	 *     AdditiveExpression returns FBinaryOperation
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FBinaryOperation
	 *     MultiplicativeExpression returns FBinaryOperation
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FBinaryOperation
	 *     PrimaryExpression returns FBinaryOperation
	 *     SimplePrimaryExpression returns FBinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=LogicalOrExpression_FBinaryOperation_1_0 op=OperatorOr right=LogicalAndExpression) | 
	 *         (left=LogicalAndExpression_FBinaryOperation_1_0 op=OperatorAnd right=EqualityExpression) | 
	 *         (left=EqualityExpression_FBinaryOperation_1_0 op=OperatorEquality right=RelationalExpression) | 
	 *         (left=RelationalExpression_FBinaryOperation_1_0 op=OperatorRelational right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_FBinaryOperation_1_0 op=OperatorAdditive right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_FBinaryOperation_1_0 op=OperatorMultiplicative right=PrimaryExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_EqualityExpression_LogicalAndExpression_LogicalOrExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, FBinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationBlock returns AnnotationBlock
	 *
	 * Constraint:
	 *     elements+=Annotation+
	 */
	protected void sequence_AnnotationBlock(ISerializationContext context, AnnotationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     rawText=ANNOTATION_STRING
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ANNOTATION__RAW_TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ANNOTATION__RAW_TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnnotationAccess().getRawTextANNOTATION_STRINGTerminalRuleCall_0(), semanticObject.getRawText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorModel returns BehaviorModel
	 *
	 * Constraint:
	 *     (name=FQN imports+=Import* behaviors+=Behavior*)
	 */
	protected void sequence_BehaviorModel(ISerializationContext context, BehaviorModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Behavior returns Behavior
	 *
	 * Constraint:
	 *     (
	 *         comment=AnnotationBlock? 
	 *         name=ID? 
	 *         componentName=ID? 
	 *         variables+=FDeclaration* 
	 *         events+=EventBinding* 
	 *         signals+=Signal* 
	 *         operations+=StandardOperation* 
	 *         name=ID? 
	 *         stateGraphs+=FStateGraph*
	 *     )
	 */
	protected void sequence_Behavior(ISerializationContext context, Behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Broadcast returns Broadcast
	 *
	 * Constraint:
	 *     (signal=ID (arguments+=ID arguments+=ID*)?)
	 */
	protected void sequence_Broadcast(ISerializationContext context, Broadcast semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractPair returns ContractPair
	 *
	 * Constraint:
	 *     (req+=Requires* ens+=Ensures*)
	 */
	protected void sequence_ContractPair(ISerializationContext context, ContractPair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DetailCode returns DetailCode
	 *
	 * Constraint:
	 *     (lines+=CC_STRING | (used?='{' lines+=STRING*))?
	 */
	protected void sequence_DetailCode(ISerializationContext context, DetailCode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ensures returns Ensures
	 *
	 * Constraint:
	 *     expr=ContractExpression
	 */
	protected void sequence_Ensures(ISerializationContext context, Ensures semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ENSURES__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ENSURES__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnsuresAccess().getExprContractExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventBinding returns EventBinding
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? trigger=EventTrigger to=Event)
	 */
	protected void sequence_EventBinding(ISerializationContext context, EventBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventOnIf returns EventOnIf
	 *
	 * Constraint:
	 *     (freq=INT | condition=LogicalOrExpression | call=MethodSignature | event=FQN | signal=ID)
	 */
	protected void sequence_EventOnIf(ISerializationContext context, EventOnIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventTrigger returns EventTrigger
	 *
	 * Constraint:
	 *     event=EventOnIf
	 */
	protected void sequence_EventTrigger(ISerializationContext context, EventTrigger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.EVENT_TRIGGER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.EVENT_TRIGGER__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventTriggerAccess().getEventEventOnIfParserRuleCall_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=ID (arguments+=ID arguments+=ID*)?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTypedElement returns FArgument
	 *     FArgument returns FArgument
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? type=FTypeRef array?='['? name=ID)
	 */
	protected void sequence_FArgument(ISerializationContext context, FArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FType returns FArrayType
	 *     FArrayType returns FArrayType
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? public?='public'? name=ID elementType=FTypeRef)
	 */
	protected void sequence_FArrayType(ISerializationContext context, FArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FBooleanConstant
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FBooleanConstant
	 *     LogicalAndExpression returns FBooleanConstant
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FBooleanConstant
	 *     EqualityExpression returns FBooleanConstant
	 *     EqualityExpression.FBinaryOperation_1_0 returns FBooleanConstant
	 *     RelationalExpression returns FBooleanConstant
	 *     RelationalExpression.FBinaryOperation_1_0 returns FBooleanConstant
	 *     AdditiveExpression returns FBooleanConstant
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FBooleanConstant
	 *     MultiplicativeExpression returns FBooleanConstant
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FBooleanConstant
	 *     PrimaryExpression returns FBooleanConstant
	 *     SimplePrimaryExpression returns FBooleanConstant
	 *     FConstant returns FBooleanConstant
	 *     FBooleanConstant returns FBooleanConstant
	 *
	 * Constraint:
	 *     val=EBoolean
	 */
	protected void sequence_FBooleanConstant(ISerializationContext context, FBooleanConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FBOOLEAN_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FBOOLEAN_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFBooleanConstantAccess().getValEBooleanParserRuleCall_0(), semanticObject.isVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FInitializerExpression returns FBracketInitializer
	 *     FInitializer returns FBracketInitializer
	 *     FBracketInitializer returns FBracketInitializer
	 *
	 * Constraint:
	 *     (elements+=FElementInitializer elements+=FElementInitializer*)?
	 */
	protected void sequence_FBracketInitializer(ISerializationContext context, FBracketInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FInitializerExpression returns FCompoundInitializer
	 *     FInitializer returns FCompoundInitializer
	 *     FCompoundInitializer returns FCompoundInitializer
	 *
	 * Constraint:
	 *     (elements+=FFieldInitializer elements+=FFieldInitializer*)?
	 */
	protected void sequence_FCompoundInitializer(ISerializationContext context, FCompoundInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTypedElement returns FConstantDef
	 *     FConstantDef returns FConstantDef
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? type=FTypeRef array?='['? name=ID rhs=FInitializerExpression)
	 */
	protected void sequence_FConstantDef(ISerializationContext context, FConstantDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FDeclaration returns FDeclaration
	 *     FTypedElement returns FDeclaration
	 *
	 * Constraint:
	 *     (type=FTypeRef array?='['? name=ID rhs=FInitializerExpression?)
	 */
	protected void sequence_FDeclaration(ISerializationContext context, FDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FDoubleConstant
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FDoubleConstant
	 *     LogicalAndExpression returns FDoubleConstant
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FDoubleConstant
	 *     EqualityExpression returns FDoubleConstant
	 *     EqualityExpression.FBinaryOperation_1_0 returns FDoubleConstant
	 *     RelationalExpression returns FDoubleConstant
	 *     RelationalExpression.FBinaryOperation_1_0 returns FDoubleConstant
	 *     AdditiveExpression returns FDoubleConstant
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FDoubleConstant
	 *     MultiplicativeExpression returns FDoubleConstant
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FDoubleConstant
	 *     PrimaryExpression returns FDoubleConstant
	 *     SimplePrimaryExpression returns FDoubleConstant
	 *     FConstant returns FDoubleConstant
	 *     FDoubleConstant returns FDoubleConstant
	 *
	 * Constraint:
	 *     val=E_DOUBLE_OBJECT
	 */
	protected void sequence_FDoubleConstant(ISerializationContext context, FDoubleConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FDOUBLE_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FDOUBLE_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFDoubleConstantAccess().getValE_DOUBLE_OBJECTTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FElementInitializer returns FElementInitializer
	 *
	 * Constraint:
	 *     (first=FInitializerExpression second=FInitializerExpression?)
	 */
	protected void sequence_FElementInitializer(ISerializationContext context, FElementInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FEventOnIf returns FEventOnIf
	 *
	 * Constraint:
	 *     name=Event?
	 */
	protected void sequence_FEventOnIf(ISerializationContext context, FEventOnIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FFieldInitializer returns FFieldInitializer
	 *
	 * Constraint:
	 *     (element=[FField|ID] value=FInitializerExpression)
	 */
	protected void sequence_FFieldInitializer(ISerializationContext context, FFieldInitializer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FFIELD_INITIALIZER__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FFIELD_INITIALIZER__ELEMENT));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FFIELD_INITIALIZER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FFIELD_INITIALIZER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFFieldInitializerAccess().getElementFFieldIDTerminalRuleCall_0_0_1(), semanticObject.eGet(BehaviorPackage.Literals.FFIELD_INITIALIZER__ELEMENT, false));
		feeder.accept(grammarAccess.getFFieldInitializerAccess().getValueFInitializerExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FField returns FField
	 *     FTypedElement returns FField
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? type=FTypeRef array?='['? name=ID)
	 */
	protected void sequence_FField(ISerializationContext context, FField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FFloatConstant
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FFloatConstant
	 *     LogicalAndExpression returns FFloatConstant
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FFloatConstant
	 *     EqualityExpression returns FFloatConstant
	 *     EqualityExpression.FBinaryOperation_1_0 returns FFloatConstant
	 *     RelationalExpression returns FFloatConstant
	 *     RelationalExpression.FBinaryOperation_1_0 returns FFloatConstant
	 *     AdditiveExpression returns FFloatConstant
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FFloatConstant
	 *     MultiplicativeExpression returns FFloatConstant
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FFloatConstant
	 *     PrimaryExpression returns FFloatConstant
	 *     SimplePrimaryExpression returns FFloatConstant
	 *     FConstant returns FFloatConstant
	 *     FFloatConstant returns FFloatConstant
	 *
	 * Constraint:
	 *     val=E_FLOAT_OBJECT
	 */
	protected void sequence_FFloatConstant(ISerializationContext context, FFloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FFLOAT_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FFLOAT_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFFloatConstantAccess().getValE_FLOAT_OBJECTTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FGuard returns FGuard
	 *
	 * Constraint:
	 *     condition=LogicalOrExpression
	 */
	protected void sequence_FGuard(ISerializationContext context, FGuard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FGUARD__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FGUARD__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFGuardAccess().getConditionLogicalOrExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FIntegerConstant
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FIntegerConstant
	 *     LogicalAndExpression returns FIntegerConstant
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FIntegerConstant
	 *     EqualityExpression returns FIntegerConstant
	 *     EqualityExpression.FBinaryOperation_1_0 returns FIntegerConstant
	 *     RelationalExpression returns FIntegerConstant
	 *     RelationalExpression.FBinaryOperation_1_0 returns FIntegerConstant
	 *     AdditiveExpression returns FIntegerConstant
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FIntegerConstant
	 *     MultiplicativeExpression returns FIntegerConstant
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FIntegerConstant
	 *     PrimaryExpression returns FIntegerConstant
	 *     SimplePrimaryExpression returns FIntegerConstant
	 *     FConstant returns FIntegerConstant
	 *     FIntegerConstant returns FIntegerConstant
	 *
	 * Constraint:
	 *     val=E_BigInteger
	 */
	protected void sequence_FIntegerConstant(ISerializationContext context, FIntegerConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FINTEGER_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FINTEGER_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFIntegerConstantAccess().getValE_BigIntegerParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FIntegerInterval returns FIntegerInterval
	 *
	 * Constraint:
	 *     (lowerBound=INTERVAL_BOUND? upperBound=INTERVAL_BOUND?)
	 */
	protected void sequence_FIntegerInterval(ISerializationContext context, FIntegerInterval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FType returns FMapType
	 *     FMapType returns FMapType
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? public?='public'? name=ID keyType=FTypeRef valueType=FTypeRef)
	 */
	protected void sequence_FMapType(ISerializationContext context, FMapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FQualifiedElementRef
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FQualifiedElementRef
	 *     LogicalAndExpression returns FQualifiedElementRef
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FQualifiedElementRef
	 *     EqualityExpression returns FQualifiedElementRef
	 *     EqualityExpression.FBinaryOperation_1_0 returns FQualifiedElementRef
	 *     RelationalExpression returns FQualifiedElementRef
	 *     RelationalExpression.FBinaryOperation_1_0 returns FQualifiedElementRef
	 *     AdditiveExpression returns FQualifiedElementRef
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FQualifiedElementRef
	 *     MultiplicativeExpression returns FQualifiedElementRef
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FQualifiedElementRef
	 *     PrimaryExpression returns FQualifiedElementRef
	 *     SimplePrimaryExpression returns FQualifiedElementRef
	 *     FQualifiedElementRef returns FQualifiedElementRef
	 *     FQualifiedElementRef.FQualifiedElementRef_2_0 returns FQualifiedElementRef
	 *
	 * Constraint:
	 *     (element=FQN | (qualifier=FQualifiedElementRef_FQualifiedElementRef_2_0 field=[FField|ID]))
	 */
	protected void sequence_FQualifiedElementRef(ISerializationContext context, FQualifiedElementRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FStateGraph returns FStateGraph
	 *
	 * Constraint:
	 *     (initial=[FState|ID] states+=FState*)
	 */
	protected void sequence_FStateGraph(ISerializationContext context, FStateGraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FState returns FState
	 *
	 * Constraint:
	 *     (
	 *         comment=AnnotationBlock? 
	 *         name=ID 
	 *         (entryAction=CC_STRING broadcastEntry=Broadcast?)? 
	 *         (exitAction=CC_STRING broadcastExit=Broadcast?)? 
	 *         (doAction=CC_STRING boradcastDo=Broadcast?)? 
	 *         transitions+=FTransition*
	 *     )
	 */
	protected void sequence_FState(ISerializationContext context, FState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FStringConstant
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FStringConstant
	 *     LogicalAndExpression returns FStringConstant
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FStringConstant
	 *     EqualityExpression returns FStringConstant
	 *     EqualityExpression.FBinaryOperation_1_0 returns FStringConstant
	 *     RelationalExpression returns FStringConstant
	 *     RelationalExpression.FBinaryOperation_1_0 returns FStringConstant
	 *     AdditiveExpression returns FStringConstant
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FStringConstant
	 *     MultiplicativeExpression returns FStringConstant
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FStringConstant
	 *     PrimaryExpression returns FStringConstant
	 *     SimplePrimaryExpression returns FStringConstant
	 *     FConstant returns FStringConstant
	 *     FStringConstant returns FStringConstant
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_FStringConstant(ISerializationContext context, FStringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FSTRING_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FSTRING_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFStringConstantAccess().getValSTRINGTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FType returns FStructType
	 *     FStructType returns FStructType
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? public?='public'? name=ID (base=[FStructType|FQN] | polymorphic?='polymorphic')? elements+=FField*)
	 */
	protected void sequence_FStructType(ISerializationContext context, FStructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTransition returns FTransition
	 *
	 * Constraint:
	 *     (trigger=FTrigger guard=FGuard? to=[FState|ID] (action=CC_STRING broadcast=Broadcast?)?)
	 */
	protected void sequence_FTransition(ISerializationContext context, FTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTrigger returns FTrigger
	 *
	 * Constraint:
	 *     event=FEventOnIf
	 */
	protected void sequence_FTrigger(ISerializationContext context, FTrigger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FTRIGGER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FTRIGGER__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTriggerAccess().getEventFEventOnIfParserRuleCall_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FType returns FTypeDef
	 *     FTypeDef returns FTypeDef
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? public?='public'? name=ID actualType=FTypeRef)
	 */
	protected void sequence_FTypeDef(ISerializationContext context, FTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTypeRef returns FTypeRef
	 *
	 * Constraint:
	 *     (predefined=FBasicTypeId | derived=[FType|FQN] | interval=FIntegerInterval)
	 */
	protected void sequence_FTypeRef(ISerializationContext context, FTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns FUnaryOperation
	 *     LogicalOrExpression.FBinaryOperation_1_0 returns FUnaryOperation
	 *     LogicalAndExpression returns FUnaryOperation
	 *     LogicalAndExpression.FBinaryOperation_1_0 returns FUnaryOperation
	 *     EqualityExpression returns FUnaryOperation
	 *     EqualityExpression.FBinaryOperation_1_0 returns FUnaryOperation
	 *     RelationalExpression returns FUnaryOperation
	 *     RelationalExpression.FBinaryOperation_1_0 returns FUnaryOperation
	 *     AdditiveExpression returns FUnaryOperation
	 *     AdditiveExpression.FBinaryOperation_1_0 returns FUnaryOperation
	 *     MultiplicativeExpression returns FUnaryOperation
	 *     MultiplicativeExpression.FBinaryOperation_1_0 returns FUnaryOperation
	 *     PrimaryExpression returns FUnaryOperation
	 *     SimplePrimaryExpression returns FUnaryOperation
	 *     FUnaryOperation returns FUnaryOperation
	 *
	 * Constraint:
	 *     (op=OperatorUnary operand=SimplePrimaryExpression)
	 */
	protected void sequence_FUnaryOperation(ISerializationContext context, FUnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FUNARY_OPERATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FUNARY_OPERATION__OP));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FUNARY_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FUNARY_OPERATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFUnaryOperationAccess().getOpOperatorUnaryEnumRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getFUnaryOperationAccess().getOperandSimplePrimaryExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FType returns FUnionType
	 *     FUnionType returns FUnionType
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? public?='public'? name=ID base=[FUnionType|FQN]? elements+=FField*)
	 */
	protected void sequence_FUnionType(ISerializationContext context, FUnionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importedNamespace=ImportedFQN? importURI=STRING alias=ID?)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodSignature returns MethodSignature
	 *
	 * Constraint:
	 *     (name=FQN (arguments+=VarDecl arguments+=VarDecl*)? returnType=RefableType?)
	 */
	protected void sequence_MethodSignature(ISerializationContext context, MethodSignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefableType returns RefableType
	 *
	 * Constraint:
	 *     (type=[FTypeRef|FQN] ref?='ref'?)
	 */
	protected void sequence_RefableType(ISerializationContext context, RefableType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requires returns Requires
	 *
	 * Constraint:
	 *     expr=ContractExpression
	 */
	protected void sequence_Requires(ISerializationContext context, Requires semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.REQUIRES__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.REQUIRES__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequiresAccess().getExprContractExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SignalSignature returns SignalSignature
	 *
	 * Constraint:
	 *     (name=ID (arguments+=VarDecl arguments+=VarDecl*)?)
	 */
	protected void sequence_SignalSignature(ISerializationContext context, SignalSignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signal returns Signal
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? signal=SignalSignature)
	 */
	protected void sequence_Signal(ISerializationContext context, Signal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpecificationBlock returns SpecificationBlock
	 *
	 * Constraint:
	 *     (comment=AnnotationBlock? contracts+=ContractPair contracts+=ContractPair*)
	 */
	protected void sequence_SpecificationBlock(ISerializationContext context, SpecificationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns StandardOperation
	 *     StandardOperation returns StandardOperation
	 *
	 * Constraint:
	 *     (
	 *         comment=AnnotationBlock? 
	 *         override?='override'? 
	 *         name=ID 
	 *         (arguments+=VarDecl arguments+=VarDecl*)? 
	 *         (returnType=FTypeRef array?='['?)? 
	 *         contract=SpecificationBlock 
	 *         detailCode=DetailCode
	 *     )
	 */
	protected void sequence_StandardOperation(ISerializationContext context, StandardOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (name=ID refType=FTypeRef array?='['? varargs?='varargs'?)
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
